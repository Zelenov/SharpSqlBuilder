using System;
using System.Collections.Generic;
using System.Linq;
using SharpSqlBuilder.Blocks;
using SharpSqlBuilder.Entities;
using SharpSqlBuilder.Extensions;
using SharpSqlBuilder.Maps;
using SharpSqlBuilder.Operators;

namespace SharpSqlBuilder.Builders
{
    public class SqlInsertBuilder : SqlBuilderBase
    {
        protected readonly OnConflictBlock ConflictUpdate = new OnConflictBlock();

        protected readonly Dictionary<SqlInsertPosition, CustomSqlBlock> CustomBlocks =
            new Dictionary<SqlInsertPosition, CustomSqlBlock>
            {
                {SqlInsertPosition.Start, new CustomSqlBlock()},
                {SqlInsertPosition.Into, new CustomSqlBlock()},
                {SqlInsertPosition.Values, new CustomSqlBlock()},
                {SqlInsertPosition.Conflict, new CustomSqlBlock()},
                {SqlInsertPosition.DoUpdate, new CustomSqlBlock()},
                {SqlInsertPosition.Where, new CustomSqlBlock()},
                {SqlInsertPosition.Return, new CustomSqlBlock()}
            };

        protected readonly DbMap DbMap;
        protected readonly DoUpdateBlock DoUpdateBlock = new DoUpdateBlock();
        protected readonly InsertColumnsBlock InsertColumnsBlock = new InsertColumnsBlock();
        protected readonly InsertIntoBlock InsertIntoBlock;
        protected readonly InsertPropertiesBlock InsertValuesBlock = new InsertPropertiesBlock();
        protected readonly ReturningBlock ReturningBlock = new ReturningBlock();
        protected readonly WhereBlock WhereBlock = new WhereBlock();
        protected SqlInsertPosition CurrentPosition = SqlInsertPosition.Start;


        public SqlInsertBuilder(DbMap dbMap)
        {
            DbMap = dbMap;
            InsertIntoBlock = new InsertIntoBlock(new TableEntity(dbMap ?? throw new ArgumentException(nameof(dbMap))));
            CurrentPosition = SqlInsertPosition.Into;
        }

        public override bool Present(SqlOptions sqlOptions) =>
            InsertIntoBlock?.Present(sqlOptions) == true && InsertColumnsBlock.Present(sqlOptions) &&
            InsertValuesBlock.Present(sqlOptions);


        public SqlInsertBuilder Values(IEnumerable<DbMapItem> dbMapItems)
        {
            var mapItems = dbMapItems as DbMapItem[] ?? dbMapItems.ToArray();
            InsertColumnsBlock.AddRange(mapItems.Select(m => new ColumnEntity(m)));
            InsertValuesBlock.AddRange(mapItems.Select(m => m.Property()));
            CurrentPosition = SqlInsertPosition.Values;
            return this;
        }

        public SqlInsertBuilder CustomSql(string customSql, SqlInsertPosition? type = null)
        {
            var customSelectType = type ?? CurrentPosition;
            var block = CustomBlocks[customSelectType];
            block.Add(new SqlCustomSqlBlock(customSql));
            return this;
        }

        public SqlInsertBuilder OnConflict(IEnumerable<DbMapItem> dbMapItems)
        {
            ConflictUpdate.AddRange(dbMapItems.Select(m => new ColumnEntity(m)));
            CurrentPosition = SqlInsertPosition.Conflict;
            return this;
        }

        public SqlInsertBuilder DoUpdate(IEnumerable<DbMapItem> dbMapItems)
        {
            DoUpdateBlock.AddRange(dbMapItems.Select(m => new OnConflictUpdateValueBlock(m)));
            CurrentPosition = SqlInsertPosition.DoUpdate;
            return this;
        }

        public SqlInsertBuilder Where(params Operator[] operators)
        {
            WhereBlock.AddRange(operators);
            CurrentPosition = SqlInsertPosition.Where;
            return this;
        }

        public SqlInsertBuilder Returns(IEnumerable<DbMapItem> dbMapItems)
        {
            ReturningBlock.AddRange(dbMapItems.Select(m => new ColumnEntity(m)));
            CurrentPosition = SqlInsertPosition.Return;
            return this;
        }

        public SqlInsertBuilder AllStaticValues() => Values(DbMap.StaticValues);

        public SqlInsertBuilder OnKeysConflict() => OnConflict(DbMap.Keys);

        public SqlInsertBuilder DoUpdateAllStaticValues() => DoUpdate(DbMap.NotKeys);

        public SqlInsertBuilder ReturnsAutoGeneratedValues() => Returns(DbMap.AutoGenerated);

        public SqlInsertBuilder ReturnsAllValues() => Returns(DbMap);


        public override string BuildSql(SqlOptions sqlOptions)
        {
            if (sqlOptions == null)
                throw new ArgumentException(nameof(sqlOptions));

            CheckBeforeBuild(sqlOptions);
            IEnumerable<SqlBuilderEntity> data = new SqlBuilderEntity[]
            {
                CustomBlocks[SqlInsertPosition.Start],
                InsertIntoBlock,
                CustomBlocks[SqlInsertPosition.Into],
                InsertColumnsBlock,
                InsertValuesBlock,
                CustomBlocks[SqlInsertPosition.Values],
                ConflictUpdate,
                CustomBlocks[SqlInsertPosition.Conflict],
                DoUpdateBlock,
                CustomBlocks[SqlInsertPosition.DoUpdate],
                WhereBlock,
                CustomBlocks[SqlInsertPosition.Where],
                ReturningBlock,
                CustomBlocks[SqlInsertPosition.Return]
            };
            var commands = data.Where(b => CheckBlock(b, sqlOptions)).Select(b => b.BuildSql(sqlOptions));
            return string.Join(sqlOptions.NewLine(), commands);
        }
    }
}