using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Linq;
using System.Linq.Expressions;
using SharpSqlBuilder.Attributes;
using SharpSqlBuilder.Extensions;

namespace SharpSqlBuilder.Maps
{
    public class SqlTable : IEnumerable<SqlColumn>
    {
        public static string DefaultSchema;
        protected readonly IList<SqlColumn> Columns = new List<SqlColumn>();

        protected readonly IDictionary<string, SqlColumn> ColumnsDictionary = new Dictionary<string, SqlColumn>();
        public readonly string Schema;
        public readonly string TableName;
        private static readonly ConcurrentDictionary<Type, SqlTable> Tables = new ConcurrentDictionary<Type, SqlTable>();

        public SqlTable(string schema, string tableName)
        {
            TableName = tableName ?? throw new ArgumentException(nameof(tableName));
            Schema = schema ?? DefaultSchema;
        }

        public static SqlTable<T> ForType<T>()
        {
            var r = Tables.GetOrAdd(typeof(SqlTable<T>), type => new SqlTable<T>());
            return (SqlTable<T>)r;
        }
        public IEnumerable<SqlColumn> AutoGeneratedColumns => Columns.Where(v => v.AutoGenerated);
        public IEnumerable<SqlColumn> Keys => Columns.Where(v => v.IsKey);
        public IEnumerable<SqlColumn> NotKeys => Columns.Where(v => !v.IsKey);
        public IEnumerable<SqlColumn> StaticColumns => Columns.Where(v => !v.AutoGenerated);
        public IEnumerable<SqlColumn> UpdatableColumns => Columns.Where(v => !v.AutoGenerated && !v.IsKey && v.Update);

        public SqlColumn this[string property] => ColumnsDictionary[property];

        IEnumerator<SqlColumn> IEnumerable<SqlColumn>.GetEnumerator() => Columns.GetEnumerator();

        public IEnumerator GetEnumerator() => ((IEnumerable) Columns).GetEnumerator();

        public void AddRange(IEnumerable<SqlColumn> items)
        {
            foreach (var dbMapItem in items)
                Add(dbMapItem);
        }

        public void Add(SqlColumn sqlColumn)
        {
            ColumnsDictionary.Add(sqlColumn.PropertyName, sqlColumn);
            Columns.Add(sqlColumn);
        }
    }


    public class SqlTable<T> : SqlTable
    {
        public readonly Type Type;

        public SqlTable() : base(GetSchema(), GetTableName())
        {
            Type = typeof(T);
            AddRange(GetColumns());
        }

        public SqlColumn this[Expression<Func<T, object>> exp] => base[exp.GetPropertyInfo().Name];

        protected IEnumerable<SqlColumn> GetColumns()
        {
            var type = typeof(T);
            return type.GetProperties()
               .Where(p => p.GetAttribute<SqlIgnore>() == null)
               .Select(p => new PropertySqlColumn(p) {Parent = this});
        }

        protected static string GetTableName()
        {
            var type = typeof(T);
            var tableNameAttr = GetAttribute<TableAttribute>(type);
            return tableNameAttr?.Name;
        }

        protected static string GetSchema()
        {
            var type = typeof(T);
            var tableNameAttr = GetAttribute<TableAttribute>(type);
            return tableNameAttr?.Schema;
        }

        public static TAttribute GetAttribute<TAttribute>(Type t) where TAttribute : Attribute
        {
            var type = typeof(TAttribute);
            var attr = (TAttribute) Attribute.GetCustomAttribute(t, type);
            return attr;
        }
    }
}